"use strict";(self.webpackChunk_N_E=self.webpackChunk_N_E||[]).push([[9700],{29700:(e,r,t)=>{t.d(r,{At:()=>b,Dg:()=>u,Kv:()=>i,Od:()=>d,Qt:()=>p,VN:()=>g,Vf:()=>y,YE:()=>s,_z:()=>w,lk:()=>v,pV:()=>h,ri:()=>f,sy:()=>n,wx:()=>m,zh:()=>E});var o=t(35317),a=t(25610);let s=async(e,r)=>{try{let t=(0,o.doc)(a.db,e,r),s=await (0,o.x7)(t);if(s.exists())return Object.assign({id:s.id},s.data());return null}catch(e){throw console.error("Error getting document:",e),e}},c=async(e,r,t)=>{try{let s=(0,o.doc)(a.db,e,r);await (0,o.mZ)(s,Object.assign(Object.assign({},t),{updatedAt:(0,o.serverTimestamp)()}))}catch(e){throw console.error("Error updating document:",e),e}},l=async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:[],t=arguments.length>2?arguments[2]:void 0,s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:"desc",c=arguments.length>4?arguments[4]:void 0;try{let l=(0,o.collection)(a.db,e);return r.forEach(e=>{l=(0,o.query)(l,(0,o.where)(e.field,e.operator,e.value))}),t&&(l=(0,o.query)(l,(0,o.My)(t,s))),c&&(l=(0,o.query)(l,(0,o.AB)(c))),(await (0,o.getDocs)(l)).docs.map(e=>Object.assign({id:e.id},e.data()))}catch(e){throw console.error("Error querying documents:",e),e}},n=function(e,r){let t=arguments.length>2&&void 0!==arguments[2]?arguments[2]:[],s=arguments.length>3?arguments[3]:void 0,c=arguments.length>4&&void 0!==arguments[4]?arguments[4]:"desc",l=(0,o.collection)(a.db,e);return t.forEach(e=>{l=(0,o.query)(l,(0,o.where)(e.field,e.operator,e.value))}),s&&(l=(0,o.query)(l,(0,o.My)(s,c))),(0,o.onSnapshot)(l,e=>{r(e.docs.map(e=>Object.assign({id:e.id},e.data())))})},i=async(e,r)=>{try{await c("orders",e,{status:r,updatedAt:(0,o.serverTimestamp)()})}catch(e){throw console.error("Error updating order status:",e),e}},d=async e=>{try{return await l("orders",[{field:"sellerId",operator:"==",value:e}],"createdAt","desc")}catch(e){throw console.error("Error listing seller orders:",e),e}},u=async(e,r)=>{try{let t=(await l("chats",[{field:"participants",operator:"array-contains",value:e}])).find(e=>e.participants.includes(r));if(t)return t.id;return(await (0,o.addDoc)((0,o.collection)(a.db,"chats"),{participants:[e,r],lastMessage:null,lastMessageTime:null,createdAt:(0,o.serverTimestamp)()})).id}catch(e){throw console.error("Error starting chat:",e),e}},w=async(e,r,t,s)=>{try{let l=await (0,o.addDoc)((0,o.collection)(a.db,"chats",e,"messages"),{text:t,senderId:r,senderName:s,createdAt:(0,o.serverTimestamp)()});return await c("chats",e,{lastMessage:t,lastMessageTime:(0,o.serverTimestamp)()}),l.id}catch(e){throw console.error("Error sending message:",e),e}},g=async e=>{try{return await l("chats",[{field:"participants",operator:"array-contains",value:e}],"lastMessageTime","desc")}catch(e){throw console.error("Error getting user chats:",e),e}},h=async(e,r)=>{try{let t=(0,o.doc)(a.db,"follows","".concat(e,"_").concat(r));if((await (0,o.x7)(t)).exists())return void console.log("User ".concat(e," is already following user ").concat(r));let s=(0,o.wP)(a.db),c=(0,o.doc)(a.db,"users",e);s.update(c,{following:(0,o.GV)(1),updatedAt:(0,o.serverTimestamp)()});let l=(0,o.doc)(a.db,"users",r);s.update(l,{followers:(0,o.GV)(1),updatedAt:(0,o.serverTimestamp)()}),s.set(t,{followerId:e,followingId:r,createdAt:(0,o.serverTimestamp)()}),await s.commit(),console.log("User ".concat(e," followed user ").concat(r))}catch(e){throw console.error("Error following user:",e),e}},p=async(e,r)=>{try{let t=(0,o.doc)(a.db,"follows","".concat(e,"_").concat(r));if(!(await (0,o.x7)(t)).exists())return void console.log("User ".concat(e," is not following user ").concat(r));let s=(0,o.wP)(a.db),c=(0,o.doc)(a.db,"users",e);s.update(c,{following:(0,o.GV)(-1),updatedAt:(0,o.serverTimestamp)()});let l=(0,o.doc)(a.db,"users",r);s.update(l,{followers:(0,o.GV)(-1),updatedAt:(0,o.serverTimestamp)()}),s.delete(t),await s.commit(),console.log("User ".concat(e," unfollowed user ").concat(r))}catch(e){throw console.error("Error unfollowing user:",e),e}},f=async e=>{try{let r=(0,o.collection)(a.db,"follows"),t=(0,o.query)(r,(0,o.where)("followingId","==",e));return(await (0,o.getDocs)(t)).docs.map(e=>e.data().followerId)}catch(e){return console.error("Error getting user followers:",e),[]}},y=async e=>{try{let r=(0,o.collection)(a.db,"follows"),t=(0,o.query)(r,(0,o.where)("followerId","==",e));return(await (0,o.getDocs)(t)).docs.map(e=>e.data().followingId)}catch(e){return console.error("Error getting user following:",e),[]}},m=(e,r)=>{let t=(0,o.doc)(a.db,"users",e);return(0,o.onSnapshot)(t,e=>{if(e.exists()){let t=e.data();r({followers:t.followers||0,following:t.following||0})}else r({followers:0,following:0})})},v=(e,r,t)=>{let s=(0,o.doc)(a.db,"follows","".concat(e,"_").concat(r));return(0,o.onSnapshot)(s,e=>{t(e.exists())})},b=async(e,r)=>{try{let t=(0,o.doc)(a.db,"follows","".concat(e,"_").concat(r));return(await (0,o.x7)(t)).exists()}catch(e){return console.error("Error checking follow status:",e),!1}},E=async function(e){let r=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};try{let t=[{field:"status",operator:"==",value:"active"}];r.category&&t.push({field:"category",operator:"==",value:r.category}),void 0!==r.minPrice&&t.push({field:"price",operator:">=",value:r.minPrice}),void 0!==r.maxPrice&&t.push({field:"price",operator:"<=",value:r.maxPrice});let o=await l("products",t,"createdAt","desc",50);if(e){let r=e.toLowerCase();return o.filter(e=>{var t,o,a;return(null==(t=e.title)?void 0:t.toLowerCase().includes(r))||(null==(o=e.description)?void 0:o.toLowerCase().includes(r))||(null==(a=e.brand)?void 0:a.toLowerCase().includes(r))})}return o}catch(e){throw console.error("Error searching products:",e),e}}}}]);